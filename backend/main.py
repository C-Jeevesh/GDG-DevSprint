from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import time
from typing import List, Optional

# --- Pydantic Model for Data Validation (Complaint Schema) ---
class Complaint(BaseModel):
    id: Optional[int] = None # Will be generated by the backend
    user_email: Optional[str] = "anonymous@user.com" # Placeholder for future auth
    type: str
    location: str
    description: str
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    status: str = "Pending"
    timestamp: float = time.time()
    level: str = "alert-high" # Default level for new reports

# --- IN-MEMORY DATA STORE (For demonstration) ---
complaint_counter = 1001
IN_MEMORY_COMPLAINTS: List[Complaint] = []
# Initialize with a mock complaint
IN_MEMORY_COMPLAINTS.append(Complaint(
    id=1000,
    type="Accident",
    location="Mock Location, Near City Center",
    description="Car accident involving two vehicles.",
    latitude=12.975,
    longitude=77.605,
    status="In Progress",
    level="alert-high"
))


# --- FastAPI App Setup ---
app = FastAPI(title="LOCONO Safety Backend")

# --- CORS Configuration ---
# Allows the React frontend running on a different port (e.g., 5173) to communicate with this API (8000)
origins = [
    "http://localhost:5173", # Your Vite development server
    "http://127.0.0.1:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# --- API Endpoints ---

@app.get("/")
def read_root():
    """Health check endpoint."""
    return {"message": "LOCONO Backend is Running ðŸš€"}


@app.post("/api/complaints")
def forge_complaint(new_complaint_data: Complaint):
    """Handles submission of a new complaint from the User Dashboard."""
    global complaint_counter
    
    # 1. Assign ID and set timestamp
    new_complaint_data.id = complaint_counter
    new_complaint_data.timestamp = time.time()
    complaint_counter += 1
    
    # 2. Save to in-memory store
    IN_MEMORY_COMPLAINTS.append(new_complaint_data)
    
    # 3. Return confirmation
    return {
        "status": "success",
        "message": f"Complaint #{new_complaint_data.id} received and logged.",
        "data": new_complaint_data.model_dump()
    }


@app.get("/api/police/alerts", response_model=List[Complaint])
def get_alerts_for_police():
    """Provides a list of all current, active complaints for the Police Dashboard."""
    # In a real app, this would query a database
    
    # Sort by timestamp (most recent first) and only include "Pending" or "In Progress"
    active_complaints = sorted(
        [c for c in IN_MEMORY_COMPLAINTS if c.status in ["Pending", "In Progress"]],
        key=lambda c: c.timestamp,
        reverse=True
    )
    
    return active_complaints